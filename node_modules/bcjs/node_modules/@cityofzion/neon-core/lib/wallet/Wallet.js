var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { DEFAULT_SCRYPT, DEFAULT_WALLET } from "../consts";
import logger from "../logging";
import { Account } from "./Account";
const log = logger("wallet");
/**
 * File to store private keys according to the NEP-2 specification.
 */
export class Wallet {
    constructor(obj = DEFAULT_WALLET) {
        this.name = obj.name || "myWallet";
        this.version = obj.version || DEFAULT_WALLET.version;
        this.scrypt = Object.assign({}, DEFAULT_SCRYPT, obj.scrypt);
        this.accounts = [];
        if (obj.accounts) {
            for (const acct of obj.accounts) {
                this.addAccount(acct);
            }
        }
        this.extra = obj.extra || {};
        log.info(`New Wallet created: ${this.name}`);
    }
    get [Symbol.toStringTag]() {
        return "Wallet";
    }
    /**
     * Returns the default Account according to the following rules:
     * 1. First Account where isDefault is true.
     * 2. First Account with a decrypted private key.
     * 3. First Account with an encrypted private key.
     * 4. First Account in the array.
     * Throws error if no accounts available.
     */
    get defaultAccount() {
        if (this.accounts.length === 0) {
            throw new Error("No accounts available in this Wallet!");
        }
        for (const acct of this.accounts) {
            if (acct.isDefault) {
                return acct;
            }
        }
        for (const acct of this.accounts) {
            if (acct.tryGet("privateKey") || acct.tryGet("WIF")) {
                return acct;
            }
        }
        for (const acct of this.accounts) {
            if (acct.encrypted) {
                return acct;
            }
        }
        return this.accounts[0];
    }
    /**
     * Adds an account.
     * @param acct Account or WalletAccount object.
     * @return Index position of Account in array.
     */
    addAccount(acct) {
        const index = this.accounts.length;
        if (!(acct instanceof Account)) {
            acct = new Account(acct);
        }
        this.accounts.push(acct);
        try {
            const address = acct.address;
            log.info(`Added Account: ${address} to Wallet ${this.name}`);
        }
        catch (err) {
            log.warn(`Encrypted account added to Wallet ${this.name}. You will not be able to export this wallet without first decrypting this account`);
        }
        return index;
    }
    /**
     * Attempts to decrypt Account at index in array.
     * @param index Index of Account in array.
     * @param keyphrase keyphrase
     * @return Promise of decryption success/failure.
     */
    decrypt(index, keyphrase) {
        return __awaiter(this, void 0, void 0, function* () {
            if (index < 0) {
                return Promise.reject(`Index cannot be negative! index: ${index}`);
            }
            if (index >= this.accounts.length) {
                return Promise.reject(`Index cannot larger than Accounts array! index: ${index}`);
            }
            yield this.accounts[index].decrypt(keyphrase, this.scrypt);
            return true;
        });
    }
    /**
     * Attempts to decrypt all accounts with keyphrase.
     * @param keyphrase
     * @return Promise of accounts decryption success/failure .
     */
    decryptAll(keyphrase) {
        return Promise.all(this.accounts.map((acct, i) => this.decrypt(i, keyphrase)));
    }
    /**
     * Attempts to encrypt Account at index in array.
     * @param index Index of Account in array.
     * @param keyphrase
     * @return Promise of encryption success/failure.
     */
    encrypt(index, keyphrase) {
        return __awaiter(this, void 0, void 0, function* () {
            if (index < 0) {
                return Promise.reject("Index cannot be negative!");
            }
            if (index >= this.accounts.length) {
                return Promise.reject("Index cannot larger than Accounts array!");
            }
            yield this.accounts[index].encrypt(keyphrase, this.scrypt);
            return true;
        });
    }
    /**
     * Attempts to encrypt all accounts with keyphrase.
     * @param keyphrase
     * @return Promise of accounts encryption success/failure.
     */
    encryptAll(keyphrase) {
        return Promise.all(this.accounts.map((acct, i) => this.encrypt(i, keyphrase)));
    }
    /**
     * Export this class as a JS object.
     */
    export() {
        return {
            name: this.name,
            version: this.version,
            scrypt: this.scrypt,
            accounts: this.accounts.map(acct => acct.export()),
            extra: this.extra
        };
    }
    /**
     * Set Account at index in array to be default account.
     * @param index The index of the Account in accounts array.
     * @return this
     */
    setDefault(index) {
        for (let i = 0; i < this.accounts.length; i++) {
            this.accounts[i].isDefault = i === index;
        }
        log.info(`Set Account: ${this.accounts[index]} as default for Wallet ${this.name}`);
        return this;
    }
}
export default Wallet;
//# sourceMappingURL=Wallet.js.map