'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var crypto = require('crypto');
var Debug = require('debug');
var debug = Debug('bitcoin-net:peer');
debug.rx = Debug('bitcoin-net:messages:rx');
debug.tx = Debug('bitcoin-net:messages:tx');
var proto = require('bitcoin-protocol');
var INV = proto.constants.inventory;
var u = require('bitcoin-util');
var wrapEvents = require('event-cleanup');
var through = require('through2').obj;
var EventEmitter = require('events');
var pkg = require('../package.json');
var utils = require('./utils.js');

var SERVICES_SPV = new Buffer('0000000000000000', 'hex');
var SERVICES_FULL = new Buffer('0100000000000000', 'hex');
var BLOOMSERVICE_VERSION = 70011;

var LATENCY_EXP = 0.5; // coefficient used for latency exponential average
var INITIAL_PING_N = 4; // send this many pings when we first connect
var INITIAL_PING_INTERVAL = 250; // wait this many ms between initial pings
var MIN_TIMEOUT = 2000; // lower bound for timeouts (in case latency is low)

var serviceBits = {
  'NODE_NETWORK': 1,
  'NODE_BLOOM': 1 << 2
};
function getServices(buf) {
  var services = {};
  var lower = buf.readUInt32LE(0);
  for (var name in serviceBits) {
    var bit = serviceBits[name];
    if (lower & bit) services[name] = true;
  }
  return services;
}

var debugStream = function debugStream(f) {
  return through(function (message, enc, cb) {
    f(message);
    cb(null, message);
  });
};

module.exports = function (_EventEmitter) {
  _inherits(Peer, _EventEmitter);

  function Peer(params) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Peer);

    utils.assertParams(params);

    var _this = _possibleConstructorReturn(this, (Peer.__proto__ || Object.getPrototypeOf(Peer)).call(this));

    _this.params = params;
    _this.protocolVersion = params.protocolVersion || 70012;
    _this.minimumVersion = params.minimumVersion || 70001;
    _this.requireBloom = opts.requireBloom && true;
    _this.userAgent = opts.userAgent;
    if (!opts.userAgent) {
      if (process.browser) _this.userAgent = '/' + navigator.userAgent + '/';else _this.userAgent = '/node.js:' + process.versions.node + '/';
      _this.userAgent += pkg.name + ':' + pkg.version + '/';
    }
    if (opts.subUserAgent) _this.userAgent += opts.subUserAgent;
    _this.handshakeTimeout = opts.handshakeTimeout || 8 * 1000;
    _this.getTip = opts.getTip;
    _this.relay = opts.relay || false;
    _this.pingInterval = opts.pingInterval || 15 * 1000;
    _this.version = null;
    _this.services = null;
    _this.socket = null;
    _this.ready = false;
    _this._handshakeTimeout = null;
    _this.disconnected = false;
    _this.latency = 2 * 1000; // default to 2s

    _this.getHeadersQueue = [];
    _this.gettingHeaders = false;

    _this.setMaxListeners(200);

    if (opts.socket) _this.connect(opts.socket);
    return _this;
  }

  _createClass(Peer, [{
    key: 'send',
    value: function send(command, payload) {
      // TODO?: maybe this should error if we try to write after close?
      if (!this.socket.writable) return;
      this._encoder.write({ command: command, payload: payload });
    }
  }, {
    key: 'connect',
    value: function connect(socket) {
      var _this2 = this;

      if (!socket || !socket.readable || !socket.writable) {
        throw new Error('Must specify socket duplex stream');
      }
      this.socket = socket;
      socket.once('close', function () {
        _this2.disconnect(new Error('Socket closed'));
      });
      socket.on('error', this._error.bind(this));

      var protocolOpts = {
        magic: this.params.magic,
        messages: this.params.messages
      };

      var decoder = proto.createDecodeStream(protocolOpts);
      this._decoder = debugStream(debug.rx);
      socket.pipe(decoder).pipe(this._decoder);

      this._encoder = proto.createEncodeStream(protocolOpts);
      var encodeDebug = debugStream(debug.tx);
      this._encoder.pipe(encodeDebug).pipe(socket);

      // timeout if handshake doesn't finish fast enough
      if (this.handshakeTimeout) {
        this._handshakeTimeout = setTimeout(function () {
          _this2._handshakeTimeout = null;
          _this2._error(new Error('Peer handshake timed out'));
        }, this.handshakeTimeout);
        this.once('ready', function () {
          clearTimeout(_this2._handshakeTimeout);
          _this2._handshakeTimeout = null;
        });
      }

      // set up ping interval and initial pings
      this.once('ready', function () {
        _this2._pingInterval = setInterval(_this2.ping.bind(_this2), _this2.pingInterval);
        for (var i = 0; i < INITIAL_PING_N; i++) {
          setTimeout(_this2.ping.bind(_this2), INITIAL_PING_INTERVAL * i);
        }
      });

      this._registerListeners();
      this._sendVersion();
    }
  }, {
    key: 'disconnect',
    value: function disconnect(err) {
      if (this.disconnected) return;
      this.disconnected = true;
      if (this._handshakeTimeout) clearTimeout(this._handshakeTimeout);
      clearInterval(this._pingInterval);
      this.socket.end();
      this.emit('disconnect', err);
    }
  }, {
    key: 'ping',
    value: function ping(cb) {
      var _this3 = this;

      var start = Date.now();
      var nonce = crypto.pseudoRandomBytes(8);
      var onPong = function onPong(pong) {
        if (pong.nonce.compare(nonce) !== 0) return;
        _this3.removeListener('pong', onPong);
        var elapsed = Date.now() - start;
        _this3.latency = _this3.latency * LATENCY_EXP + elapsed * (1 - LATENCY_EXP);
        if (cb) cb(null, elapsed, _this3.latency);
      };
      this.on('pong', onPong);
      this.send('ping', { nonce: nonce });
    }
  }, {
    key: '_error',
    value: function _error(err) {
      this.emit('error', err);
      this.disconnect(err);
    }
  }, {
    key: '_registerListeners',
    value: function _registerListeners() {
      var _this4 = this;

      this._decoder.on('error', this._error.bind(this));
      this._decoder.on('data', function (message) {
        _this4.emit('message', message);
        _this4.emit(message.command, message.payload);
      });

      this._encoder.on('error', this._error.bind(this));

      this.on('version', this._onVersion);
      this.on('verack', function () {
        if (_this4.ready) return _this4._error(new Error('Got duplicate verack'));
        _this4.verack = true;
        _this4._maybeReady();
      });

      this.on('ping', function (message) {
        return _this4.send('pong', message);
      });

      this.on('block', function (block) {
        _this4.emit('block:' + block.header.getHash().toString('base64'), block);
      });
      this.on('merkleblock', function (block) {
        _this4.emit('merkleblock:' + block.header.getHash().toString('base64'), block);
      });
      this.on('tx', function (tx) {
        _this4.emit('tx:' + tx.getHash().toString('base64'), tx);
      });
    }
  }, {
    key: '_onVersion',
    value: function _onVersion(message) {
      this.services = getServices(message.services);
      if (!this.services.NODE_NETWORK) {
        return this._error(new Error('Node does not provide NODE_NETWORK service'));
      }
      this.version = message;
      if (message.version < this.minimumVersion) {
        return this._error(new Error('Peer is using an incompatible protocol version: ' + ('required: >= ' + this.minimumVersion + ', actual: ' + message.version)));
      }
      if (this.requireBloom && message.version >= BLOOMSERVICE_VERSION && !this.services.NODE_BLOOM) {
        return this._error(new Error('Node does not provide NODE_BLOOM service'));
      }
      this.send('verack');
      this._maybeReady();
    }
  }, {
    key: '_maybeReady',
    value: function _maybeReady() {
      if (!this.verack || !this.version) return;
      this.ready = true;
      this.emit('ready');
    }
  }, {
    key: '_onceReady',
    value: function _onceReady(cb) {
      if (this.ready) return cb();
      this.once('ready', cb);
    }
  }, {
    key: '_sendVersion',
    value: function _sendVersion() {
      this.send('version', {
        version: this.protocolVersion,
        services: SERVICES_SPV,
        timestamp: Math.round(Date.now() / 1000),
        receiverAddress: {
          services: SERVICES_FULL,
          address: this.socket.remoteAddress || '0.0.0.0',
          port: this.socket.remotePort || 0
        },
        senderAddress: {
          services: SERVICES_SPV,
          address: '0.0.0.0',
          port: this.socket.localPort || 0
        },
        nonce: crypto.pseudoRandomBytes(8),
        userAgent: this.userAgent,
        startHeight: this.getTip ? this.getTip().height : 0,
        relay: this.relay
      });
    }
  }, {
    key: '_getTimeout',
    value: function _getTimeout() {
      return MIN_TIMEOUT + this.latency * 10;
    }
  }, {
    key: 'getBlocks',
    value: function getBlocks(hashes, opts, cb) {
      if (typeof opts === 'function') {
        cb = opts;
        opts = {};
      }
      if (opts.timeout == null) opts.timeout = this._getTimeout();

      var timeout;
      var events = wrapEvents(this);
      var output = new Array(hashes.length);
      var remaining = hashes.length;
      hashes.forEach(function (hash, i) {
        var event = (opts.filtered ? 'merkle' : '') + 'block:' + hash.toString('base64');
        events.once(event, function (block) {
          output[i] = block;
          remaining--;
          if (remaining > 0) return;
          if (timeout != null) clearTimeout(timeout);
          cb(null, output);
        });
      });

      var inventory = hashes.map(function (hash) {
        return {
          type: opts.filtered ? INV.MSG_FILTERED_BLOCK : INV.MSG_BLOCK,
          hash: hash
        };
      });
      this.send('getdata', inventory);

      if (!opts.timeout) return;
      timeout = setTimeout(function () {
        debug('getBlocks timed out: ' + opts.timeout + ' ms, remaining: ' + remaining + '/' + hashes.length);
        events.removeAll();
        var error = new Error('Request timed out');
        error.timeout = true;
        cb(error);
      }, opts.timeout);
    }
  }, {
    key: 'getTransactions',
    value: function getTransactions(blockHash, txids, opts, cb) {
      var _this5 = this;

      if (Array.isArray(blockHash)) {
        cb = opts;
        opts = txids;
        txids = blockHash;
        blockHash = null;
      }
      if (typeof opts === 'function') {
        cb = opts;
        opts = {};
      }

      var output = new Array(txids.length);

      if (blockHash) {
        var txIndex = {};
        txids.forEach(function (txid, i) {
          txIndex[txid.toString('base64')] = i;
        });
        this.getBlocks([blockHash], opts, function (err, blocks) {
          if (err) return cb(err);
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = blocks[0].transactions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var tx = _step.value;

              var id = tx.getHash().toString('base64');
              var i = txIndex[id];
              if (i == null) continue;
              delete txIndex[id];
              output[i] = tx;
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          cb(null, output);
        });
      } else {
        if (opts.timeout == null) opts.timeout = this._getTimeout();
        // TODO: make a function for all these similar timeout request methods

        var timeout;
        var remaining = txids.length;
        var events = wrapEvents(this);
        txids.forEach(function (txid, i) {
          var hash = txid.toString('base64');
          _this5.once('tx:' + hash, function (tx) {
            output[i] = tx;
            remaining--;
            if (remaining > 0) return;
            if (timeout != null) clearTimeout(timeout);
            cb(null, output);
          });
        });

        var inventory = txids.map(function (hash) {
          return { type: INV.MSG_TX, hash: hash };
        });
        this.send('getdata', inventory);

        if (!opts.timeout) return;
        timeout = setTimeout(function () {
          debug('getTransactions timed out: ' + opts.timeout + ' ms, remaining: ' + remaining + '/' + txids.length);
          events.removeAll();
          var err = new Error('Request timed out');
          err.timeout = true;
          cb(err);
        }, opts.timeout);
      }
    }
  }, {
    key: 'getHeaders',
    value: function getHeaders(locator, opts, cb) {
      var _this6 = this;

      if (this.gettingHeaders) {
        this.getHeadersQueue.push({ locator: locator, opts: opts, cb: cb });
        debug('queued "getHeaders" request: queue size=' + this.getHeadersQueue.length);
        return;
      }
      this.gettingHeaders = true;

      if (typeof opts === 'function') {
        cb = opts;
        opts = {};
      } else if (typeof locator === 'function') {
        cb = locator;
        opts = {};
        locator = [];
      }

      opts.stop = opts.stop || u.nullHash;
      opts.timeout = opts.timeout != null ? opts.timeout : this._getTimeout();
      var timeout;
      var onHeaders = function onHeaders(headers) {
        if (timeout) clearTimeout(timeout);
        cb(null, headers);
        _this6._nextHeadersRequest();
      };
      this.once('headers', onHeaders);
      this.send('getheaders', {
        version: this.protocolVersion,
        locator: locator,
        hashStop: opts.stop
      });
      if (!opts.timeout) return;
      timeout = setTimeout(function () {
        debug('getHeaders timed out: ' + opts.timeout + ' ms');
        _this6.removeListener('headers', onHeaders);
        var error = new Error('Request timed out');
        error.timeout = true;
        cb(error);
        _this6._nextHeadersRequest();
      }, opts.timeout);
    }
  }, {
    key: '_nextHeadersRequest',
    value: function _nextHeadersRequest() {
      this.gettingHeaders = false;
      if (this.getHeadersQueue.length === 0) return;
      var req = this.getHeadersQueue.shift();
      this.getHeaders(req.locator, req.opts, req.cb);
    }
  }]);

  return Peer;
}(EventEmitter);